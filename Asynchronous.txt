*비동기 프로그래밍
: 단일 스레드인 javascript가 여러 개의 프로세스 코어를 사용해 컴퓨터 처리 능력을 활용하고
: web api에 의존적인 코드가 정확한 시점에 실행될 수 있도록 한다.

전제 : 일반적으로 프로그램의 코드는 한 번에 한 가지만 실행된다.
여러 프로세스 코어를 사용할 수 있는 시대에 컴퓨터 처리 능력을 제대로 활용하지 못하는 것이다.

-차단 코드
코드는 소스에 나타나는 순서대로 실행되며 이전 작업의 실행이 완료될 때따지 나중 작업은 실행되지 않는다.
이벤트 리스너를 사용해도 마찬가지이다.
앞서 실행한 function이 끝나기 전까지 뒤에 실행된 이벤트function은 실행되지 않는다.
이런 현상이 발생하는 이유는 javascript가 단일 스레드이기 때문이다.
스레드는 한 번에 하나의 작업만 실행한다.
단일 스레드는 그런 스레드 하나가 프로그램을 실행하는 것이기 때문에 하나의 작업만 실행할 수 있다.
Task A --> Task B --> Task C
컴퓨터에는 여러개의 코어가 있기 때문에 여러 작업을 수행할 수 있다.
Thread 1: Task A --> Task B
Thread 2: Task C --> Task D
javascript는 코어가 여러개 있어도 메인 스레드라고 하는 단일 스레드에서만 작업을 수행한다.
이러한 문제를 해결하기 위해 web worker를 사용하기 시작했다.
javascript는 처리 중 일부를 해당 worker 스레드로 보내 여러 작업을 처리한다.
Main thread: Task A --> Task C
Worker thread: Expensive task B

-비동기 코드
web worker는 유용하지만 한계가 있다.
dom(xml, html 접근을 위한 인터페이스)에 액세스할 수 없다는 것이다. 
worker는 ui를 업데이트하기 위해 직접적으로 아무것도 할 수 없다.
작업자는 내부에 100만개의 파란색 원을 렌더링할 수 없다.
기본적으로 숫자 처리만 가능하다.
앞선 함수의 반환값이 필요한 함수를 미리 실행할 경우 오류가 발생한다.
Main thread: Task A --> Task B
=a에서 이미지를 가져와 즉시 b를 수행할 경우 오류가 발생할 수 있다.

Main thread: Task A --> Task B --> |Task D|
Worker thread: Task C -----------> |      |
=d가 c,b에 의존한다고 했을 때 c가 d 실행전에 반환값을 줄 거라는 보장이 없다.

이런 문제를 해결하기 위해 promises를 사용할 수 있다.
작업이 다른 곳에서 발생하기 때문에 비동기 작업이 처리되는 동안 메인스레드가 차단되지 않는다.
Main thread: Task A                   Task B
    Promise:      |__async operation__|

비동기식 프로그래밍이 웹앱에서 특히 중요한 이유는 web api기능 때문이다.
파일 가져오기, 데이터 베이스 액세스는 즉시 반환되지 않는다.
때문에 의존하는 코드에서 에러가 발생한다.
